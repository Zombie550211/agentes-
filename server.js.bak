const express = require('express');
const cors = require('cors');
const path = require('path');
const fs = require('fs');
const nodemailer = require('nodemailer');
const { MongoClient, ObjectId } = require('mongodb');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
require('dotenv').config();

// Configuración de JWT
const JWT_SECRET = process.env.JWT_SECRET || 'tu_clave_secreta_super_segura';
const JWT_EXPIRES_IN = '24h'; // El token expira en 24 horas

// Configuración de rutas de archivos estáticos
const staticPath = path.join(__dirname, '/');
const publicPath = path.join(__dirname, '/');

// Configuración de CORS simplificada para desarrollo
const corsOptions = {
  origin: '*', // Permite cualquier origen
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS', 'PATCH'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  optionsSuccessStatus: 200
};

const app = express();
const PORT = 3000;

// Configuración de middlewares
app.use(cors(corsOptions));
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Servir archivos estáticos
app.use(express.static(staticPath, {
  extensions: ['html', 'htm'],
  setHeaders: (res, filePath) => {
    // Configurar los headers correctos para archivos estáticos
    if (filePath.endsWith('.css')) {
      res.setHeader('Content-Type', 'text/css');
    } else if (filePath.endsWith('.js')) {
      res.setHeader('Content-Type', 'application/javascript');
    }
  }
}));

// Handle CORS preflight for all routes
app.options('*', cors(corsOptions));

// Middleware para verificar el token JWT
const authenticateJWT = (req, res, next) => {
  const authHeader = req.headers.authorization;
  
  if (authHeader) {
    const token = authHeader.split(' ')[1];
    
    jwt.verify(token, JWT_SECRET, (err, user) => {
      if (err) {
        return res.sendStatus(403);
      }
      
      req.user = user;
      next();
    });
  } else {
    res.sendStatus(401);
  }
};

// Ruta protegida de ejemplo (requiere autenticación)
app.get('/api/protected', authenticateJWT, (req, res) => {
  res.json({ message: 'Ruta protegida', user: req.user });
});

// Endpoint para verificar que el servidor está funcionando
app.get('/api/status', (req, res) => {
  res.json({ status: 'ok', message: 'Servidor funcionando correctamente' });
});

// Endpoint para crear un usuario administrador inicial (solo para desarrollo)
app.post('/api/create-admin', async (req, res) => {
  try {
    const { username, password, secret } = req.body;
    
    // Verificar el secreto (solo para desarrollo)
    if (secret !== 'admin123') {
      return res.status(403).json({ 
        success: false, 
        message: 'No autorizado' 
      });
    }
    
    if (!username || !password) {
      return res.status(400).json({ 
        success: false, 
        message: 'Usuario y contraseña son requeridos' 
      });
    }
    
    // Verificar si la base de datos está conectada
    if (!db) {
      console.log('Base de datos no conectada, intentando conectar...');
      await connectToMongoDB();
    }
    
    // Verificar si el usuario ya existe
    const existingUser = await db.collection('users').findOne({ username });
    
    if (existingUser) {
      return res.status(400).json({ 
        success: false, 
        message: 'El usuario ya existe' 
      });
    }
    
    // Hashear la contraseña
    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash(password, salt);
    
    // Crear el usuario administrador
    const newUser = {
      username,
      password: hashedPassword,
      role: 'admin',
      createdAt: new Date(),
      updatedAt: new Date()
    };
    
    const result = await db.collection('users').insertOne(newUser);
    
    // No devolver la contraseña
    delete newUser.password;
    
    res.status(201).json({
      success: true,
      message: 'Usuario administrador creado exitosamente',
      user: newUser
    });
    
  } catch (error) {
    console.error('Error al crear usuario administrador:', error);
    res.status(500).json({
      success: false,
      message: 'Error al crear el usuario administrador'
    });
  }
});

// Endpoint para el login
app.post('/api/login', async (req, res) => {
  try {
    const { username, password } = req.body;
    
    if (!username || !password) {
      return res.status(400).json({ 
        success: false, 
        message: 'Usuario y contraseña son requeridos' 
      });
    }
    
    // Verificar si la base de datos está conectada
    if (!db) {
      console.log('Base de datos no conectada, intentando conectar...');
      await connectToMongoDB();
    }
    
    // Buscar el usuario en la base de datos
    const user = await db.collection('users').findOne({ username });
    
    if (!user) {
      return res.status(401).json({ 
        success: false, 
        message: 'Usuario o contraseña incorrectos' 
      });
    }
    
    // Verificar la contraseña
    const isPasswordValid = await bcrypt.compare(password, user.password);
    
    if (!isPasswordValid) {
      return res.status(401).json({ 
        success: false, 
        message: 'Usuario o contraseña incorrectos' 
      });
    }
    
    // Generar token JWT
    const token = jwt.sign(
      { 
        userId: user._id, 
        username: user.username,
        role: user.role || 'user'
      }, 
      JWT_SECRET, 
      { expiresIn: JWT_EXPIRES_IN }
    );
    
    // Enviar respuesta exitosa sin la contraseña
    const { password: _, ...userWithoutPassword } = user;
    
    res.json({
      success: true,
      message: 'Inicio de sesión exitoso',
      token,
      user: userWithoutPassword
    });
    
  } catch (error) {
    console.error('Error en el login:', error);
    res.status(500).json({
      success: false,
      message: 'Error en el servidor durante el inicio de sesión'
    });
  }
});

// Endpoint para obtener comentarios de un lead
app.get('/api/comments', (req, res) => {
  try {
    const { leadId } = req.query;
    
    if (!leadId) {
      return res.status(400).json({
        success: false,
        message: 'Se requiere el parámetro leadId'
      });
    }
    
    // Por ahora, devolvemos un array vacío como ejemplo
    // En una implementación real, buscaríamos los comentarios en la base de datos
    res.json({
      success: true,
      comments: [],
      message: 'Comentarios cargados correctamente'
    });
    
  } catch (error) {
    console.error('Error al obtener comentarios:', error);
    res.status(500).json({
      success: false,
      message: 'Error al cargar los comentarios',
      error: error.message
    });
  }
});

// Endpoint para obtener clientes desde la base de datos
app.get('/api/customers', async (req, res) => {
  try {
    console.log('Solicitud recibida en /api/customers');
    
    // Verificar si la base de datos está conectada
    if (!db) {
      console.log('Base de datos no conectada, intentando conectar...');
      await connectToMongoDB();
    }

    // Obtener los parámetros de paginación
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 50;
    const skip = (page - 1) * limit;

    console.log(`Parámetros - Página: ${page}, Límite: ${limit}, Saltar: ${skip}`);

    // Verificar colecciones disponibles
    const collections = await db.listCollections().toArray();
    console.log('Colecciones disponibles en crmagente:', collections.map(c => c.name));

    // Usamos la colección 'costumers' específicamente
    const collectionName = 'costumers';
    console.log(`Intentando acceder a la colección: ${collectionName}`);
    
    // Verificar si la colección existe
    const collectionExists = collections.some(c => c.name === collectionName);
    if (!collectionExists) {
      console.error(`La colección "${collectionName}" no existe en la base de datos crmagente`);
      return res.status(404).json({
        success: false,
        message: `La colección "${collectionName}" no existe en la base de datos`,
        availableCollections: collections.map(c => c.name)
      });
    }
    
    const customersCollection = db.collection(collectionName);
    
    // Obtener el total de documentos para la paginación
    const total = await customersCollection.countDocuments();
    console.log(`Total de documentos en la colección: ${total}`);
    
    // Consulta con paginación y ordenados por fecha de creación descendente
    const customers = await customersCollection
      .find({})
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(limit)
      .toArray();

    console.log(`Documentos encontrados: ${customers.length}`);
    if (customers.length > 0) {
      console.log('Primer documento de ejemplo:', JSON.stringify(customers[0], null, 2));
    }

    // Mapear los campos según lo que espera el frontend
    const mappedCustomers = customers.map(customer => {
      // Mapeo completo basado en la estructura que espera el frontend
      const mapped = {
        // Información básica
        _id: customer._id ? customer._id.toString() : 'sin-id',
        nombre_cliente: customer.nombre_cliente || customer.nombre || customer.name || 'Sin nombre',
        telefono_principal: customer.telefono || customer.phone || 'Sin teléfono',
        telefono_alterno: customer.telefono_alterno || customer.telefono_secundario || '',
        numero_cuenta: customer.numero_cuenta || customer.cuenta || '',
        
        // Dirección y ubicación
        direccion: customer.direccion || 'Sin dirección',
        zip_code: customer.zip_code || customer.zip || customer.codigo_postal || '',
        
        // Información del servicio
        tipo_servicios: customer.tipo_servicio || customer.producto_contratado || customer.servicios || 'Sin servicio',
        servicios: customer.servicios || customer.tipo_servicio || customer.producto_contratado || 'Sin servicio',
        sistema: customer.sistema || '',
        riesgo: customer.riesgo || 'bajo',
        
        // Fechas importantes
        dia_venta: customer.dia_venta || customer.fecha_contratacion || '',
        dia_instalacion: customer.dia_instalacion || '',
        
        // Estado y puntuación
        status: customer.status || 'activo',
        puntaje: typeof customer.puntaje === 'number' ? customer.puntaje : 0,
        
        // Información de equipo
        supervisor: customer.supervisor || '',
        mercado: customer.mercado || 'residencial',
        
        // Comentarios
        comentario: customer.comentario || customer.comentarios || '',
        motivo_llamada: customer.motivo_llamada || '',
        
        // Información adicional
        autopago: customer.autopago || false,
        
        // Mantener el objeto original para referencia
        _raw: customer
      };
      
      // Asegurarse de que los valores booleanos se conviertan a string para la visualización
      if (typeof mapped.autopago === 'boolean') {
        mapped.autopago = mapped.autopago ? 'Sí' : 'No';
      }
      
      // Convertir fechas a formato ISO si es necesario
      if (mapped.fecha_creacion && !(mapped.fecha_creacion instanceof Date)) {
        try {
          mapped.fecha_creacion = new Date(mapped.fecha_creacion).toISOString();
        } catch (e) {
          console.error('Error al formatear fecha:', e);
          mapped.fecha_creacion = new Date().toISOString();
        }
      }
      
      return mapped;
    });
    
    const response = {
      success: true,
      leads: mappedCustomers,
      total,
      page,
      pages: Math.ceil(total / limit),
      message: 'Datos de clientes cargados correctamente',
      debug: {
        collection: collectionName,
        totalDocuments: total,
        documentsReturned: mappedCustomers.length,
        availableCollections: collections.map(c => c.name)
      }
    };
    
    console.log('Enviando respuesta con', mappedCustomers.length, 'clientes');
    res.json(response);
  } catch (error) {
    console.error('Error al obtener clientes:', error);
    res.status(500).json({
      success: false,
      message: 'Error al cargar los clientes',
      error: error.message,
      stack: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  }
});

// Middleware para verificar autenticación
const requireAuth = (req, res, next) => {
  const token = req.headers.authorization?.split(' ')[1];
  
  if (!token) {
    return res.redirect('/login.html');
  }
  
  jwt.verify(token, JWT_SECRET, (err, user) => {
    if (err) {
      return res.redirect('/login.html');
    }
    req.user = user;
    next();
  });
};

// Ruta raíz - Redirigir a login.html
app.get('/', (req, res) => {
  res.redirect('/login.html');
});

// Ruta protegida para la aplicación principal
app.get('/inicio', requireAuth, (req, res) => {
  res.sendFile(path.join(publicPath, 'lead.html'));
});

// Manejar rutas de la aplicación (SPA)
app.get('*', (req, res) => {
  // Si la ruta es una extensión de archivo, devolver 404
  if (req.path.includes('.')) {
    return res.status(404).send('Archivo no encontrado');
  }
  // Para cualquier otra ruta, servir lead.html (útil para SPA)
  res.sendFile(path.join(publicPath, 'lead.html'));
});

// Conexión a MongoDB
let db;
let mongoClient; // Variable para mantener la referencia al cliente
const MONGODB_URI = process.env.MONGODB_URI || 'mongodb://localhost:27017/crmagente';

// Conectar a MongoDB
async function connectToMongoDB() {
  try {
    mongoClient = await MongoClient.connect(MONGODB_URI);
    // Especificar explícitamente la base de datos crmagente
    db = mongoClient.db('crmagente');
    console.log('Conectado a MongoDB correctamente');
    
    // Verificar colecciones disponibles
    const collections = await db.listCollections().toArray();
    console.log('Colecciones disponibles en crmagente:', collections.map(c => c.name));
    
    // Crear índices si no existen
    try {
      await db.collection('costumers').createIndex({ telefono_principal: 1 }, { unique: true });
      await db.collection('costumers').createIndex({ fecha_creacion: -1 });
      console.log('Índices creados correctamente');
    } catch (indexError) {
      console.log('Los índices ya existen o no se pudieron crear:', indexError.message);
    }
  } catch (error) {
    console.error('Error al conectar a MongoDB:', error);
    process.exit(1);
  }
}

// Endpoint unificado para obtener clientes con soporte para paginación y datos de gráficas
app.get('/api/leads', async (req, res) => {
  try {
    const { 
      page, 
      limit = 10, 
      status, 
      desde, 
      hasta,
      telefono,
      // Parámetros específicos para gráficas
      agente,
      fechaInicio,
      fechaFin,
      // Flag para indicar si se necesitan datos para gráfica
      paraGrafica = 'false'
    } = req.query;
    
    // Si es para gráfica, devolver datos agregados
    if (paraGrafica === 'true') {
      const filtro = {};
      
      if (agente) {
        filtro.agente = agente;
      }
      
      // Filtrar por rango de fechas si se proporciona
      if (fechaInicio || fechaFin) {
        filtro.creadoEn = {};
        if (fechaInicio) {
          filtro.creadoEn.$gte = new Date(fechaInicio);
        }
        if (fechaFin) {
          // Ajustar para incluir todo el día
          const finDia = new Date(fechaFin);
          finDia.setHours(23, 59, 59, 999);
          filtro.creadoEn.$lte = finDia;
        }
      }
      
      console.log('Consultando leads con filtro para gráfica:', JSON.stringify(filtro, null, 2));
      
      // Obtener los leads que coincidan con el filtro
      const leads = await db.collection('costumers').find(filtro).toArray();
      
      // Procesar los datos para la gráfica
      const datosGrafica = [];
      const ventasPorDia = {};
      
      leads.forEach(lead => {
        if (!lead.creadoEn) return;
        
        const fecha = new Date(lead.creadoEn);
        const fechaStr = fecha.toISOString().split('T')[0];
        
        if (!ventasPorDia[fechaStr]) {
          ventasPorDia[fechaStr] = {
            fecha: fechaStr,
            ventas: 0,
            puntaje: 0,
            conteo: 0
          };
        }
        
        ventasPorDia[fechaStr].ventas += 1;
        ventasPorDia[fechaStr].puntaje += Number(lead.puntaje) || 0;
        ventasPorDia[fechaStr].conteo += 1;
      });
      
      // Calcular promedios y formatear datos para la gráfica
      Object.values(ventasPorDia).forEach(dia => {
        datosGrafica.push({
          fecha: dia.fecha,
          ventas: dia.ventas,
          puntaje: dia.conteo > 0 ? dia.puntaje / dia.conteo : 0
        });
      });
      
      // Ordenar por fecha
      datosGrafica.sort((a, b) => new Date(a.fecha) - new Date(b.fecha));
      
      console.log(`Datos de gráfica generados: ${datosGrafica.length} puntos de datos`);
      
      // Asegurarse de que la respuesta sea JSON
      res.setHeader('Content-Type', 'application/json');
      return res.json(datosGrafica);
    }
    
    // Si no es para gráfica, devolver datos paginados
    const skip = page ? (parseInt(page) - 1) * parseInt(limit) : 0;
    const query = {};
    
    // Aplicar filtros
    if (status) query.status = status;
    if (telefono) query.telefono_principal = { $regex: telefono, $options: 'i' };
    
    // Filtrar por rango de fechas
    if (desde || hasta) {
      query.fecha_creacion = {};
      if (desde) query.fecha_creacion.$gte = new Date(desde);
      if (hasta) {
        const hastaDate = new Date(hasta);
        hastaDate.setHours(23, 59, 59, 999);
        query.fecha_creacion.$lte = hastaDate;
      }
    }
    
    const [leads, total] = await Promise.all([
      db.collection('costumers')
        .find(query)
        .sort({ fecha_creacion: -1 })
        .skip(skip)
        .limit(parseInt(limit))
        .toArray(),
      db.collection('costumers').countDocuments(query)
    ]);
    
    res.json({ 
      success: true, 
      data: leads,
      pagination: {
        total,
        page: parseInt(page || 1),
        totalPages: Math.ceil(total / parseInt(limit)),
        limit: parseInt(limit)
      }
    });
    
  } catch (error) {
    console.error('Error al obtener los leads:', error);
    res.status(500).json({ 
      success: false, 
      error: 'Error al cargar los leads',
      details: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

// Función para eliminar el índice único de telefono_principal si existe
async function removeUniqueIndexIfExists() {
  try {
    const indexes = await db.collection('costumers').indexes();
    const telefonoIndex = indexes.find(index => 
      index.key && index.key.telefono_principal === 1 && index.unique
    );
    
    if (telefonoIndex) {
      console.log('Eliminando índice único de telefono_principal...');
      await db.collection('costumers').dropIndex(telefonoIndex.name);
      console.log('Índice único eliminado exitosamente');
    } else {
      console.log('No se encontró un índice único en telefono_principal');
    }
  } catch (error) {
    console.error('Error al verificar/eliminar índices:', error);
  }
}

// Endpoint para crear un nuevo cliente (customer)
app.post('/api/customers', async (req, res) => {
  // Configuración CORS
  res.header('Access-Control-Allow-Origin', req.headers.origin || '*');
  res.header('Access-Control-Allow-Methods', 'POST, OPTIONS');
  res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  res.header('Access-Control-Allow-Credentials', true);
  
  // Manejar preflight
  if (req.method === 'OPTIONS') {
    return res.status(200).end();
  }

  try {
    console.log('=== NUEVA SOLICITUD EN /api/customers ===');
    console.log('Headers:', JSON.stringify(req.headers, null, 2));
    console.log('Body recibido:', JSON.stringify(req.body, null, 2));
    
    if (!req.body) {
      console.error('Error: No se recibieron datos en el cuerpo de la petición');
      return res.status(400).json({
        success: false,
        message: 'No se recibieron datos en la petición'
      });
    }
    
    const customerData = req.body;
    
    // Verificar que la conexión a la base de datos esté activa
    if (!db) {
      console.error('Error: No hay conexión a la base de datos');
      return res.status(500).json({
        success: false,
        message: 'Error de conexión con la base de datos'
      });
    }

    // Normalizar datos
    if (customerData.telefono && !customerData.telefono_principal) {
      customerData.telefono_principal = customerData.telefono;
    }

    // Validar datos requeridos
    const requiredFields = ['telefono_principal', 'nombre_cliente', 'direccion'];
    const missingFields = requiredFields.filter(field => !customerData[field]);
    
    if (missingFields.length > 0) {
      return res.status(400).json({
        success: false,
        message: `Faltan campos requeridos: ${missingFields.join(', ')}`
      });
    }

    // Eliminada la validación de duplicados para permitir guardar cualquier cliente
    // Agregar fechas de creación y actualización
    const now = new Date();
    const customerToSave = {
      ...customerData,
      creadoEn: now,
      actualizadoEn: now,
      status: customerData.status || 'activo',
      mercado: customerData.mercado || 'residencial',
      puntaje: parseFloat(customerData.puntaje) || 0,
      autopago: customerData.autopago === 'true' || customerData.autopago === true,
      // Agregar un timestamp único para evitar conflictos
      timestampUnico: now.getTime() + Math.random().toString(36).substr(2, 9)
    };
    
    // Asegurarse de que no haya un _id en los datos para que MongoDB genere uno nuevo
    delete customerToSave._id;

    try {
      console.log('=== INTENTANDO GUARDAR EN LA BASE DE DATOS ===');
      console.log('Colección:', 'costumers');
      console.log('Datos a guardar:', JSON.stringify(customerToSave, null, 2));
      
      // 1. Primero intentar eliminar el índice único si existe
      await removeUniqueIndexIfExists();
      
      // 2. Intentar insertar el cliente
      try {
        const result = await db.collection('costumers').insertOne(customerToSave);
        
        console.log('=== CLIENTE GUARDADO EXITOSAMENTE ===');
        console.log('ID del cliente:', result.insertedId);
        
        // Verificar que el cliente realmente se guardó
        const clienteGuardado = await db.collection('costumers').findOne({ _id: result.insertedId });
        console.log('Cliente verificado en la base de datos:', clienteGuardado ? 'ENCONTRADO' : 'NO ENCONTRADO');
        
        return res.status(201).json({
          success: true,
          message: 'Cliente creado exitosamente',
          id: result.insertedId
        });
      } catch (insertError) {
        // Si hay un error de duplicado, intentar forzar la inserción
        if (insertError.code === 11000) {
          console.log('=== INTENTO FALLIDO - CLIENTE DUPLICADO ===');
          console.log('Error de duplicado:', insertError.message);
          
          // Generar un ID único para forzar la inserción
          customerToSave._id = new require('mongodb').ObjectId();
          console.log('Nuevo ID generado para evitar duplicado:', customerToSave._id);
          
          // Intentar insertar con el nuevo ID
          const result = await db.collection('costumers').insertOne(customerToSave);
          console.log('Cliente guardado con nuevo ID:', result.insertedId);
          
          return res.status(201).json({
            success: true,
            message: 'Cliente creado exitosamente (se generó un nuevo ID único)',
            id: result.insertedId,
            wasDuplicate: true
          });
        }
        throw insertError; // Relanzar otros errores
      }
    } catch (insertError) {
      console.error('=== ERROR AL GUARDAR EL CLIENTE ===');
      console.error('Código de error:', insertError.code);
      console.error('Mensaje de error:', insertError.message);
      console.error('Stack trace:', insertError.stack);
      
      // Si es un error de duplicado, devolver éxito pero marcado como duplicado
      if (insertError.code === 11000) {
        return res.status(200).json({
          success: true,
          message: 'Cliente procesado (duplicado ignorado)',
          isDuplicate: true
        });
      }
      
      // Para otros errores, devolver error 500
      return res.status(500).json({
        success: false,
        message: 'Error al guardar el cliente',
        error: insertError.message
      });
    }
  } catch (error) {
    console.error('Error al crear cliente:', error);
    
    return res.status(500).json({
      success: false,
      message: 'Error al crear el cliente',
      error: error.message,
      errorCode: error.code
    });
  }
});

// Endpoint para obtener leads con filtros
app.get('/api/leads', async (req, res) => {
  try {
    const { agente, fechaInicio, fechaFin } = req.query;
    
    // Construir el filtro de consulta
    const filtro = {};
    
    if (agente) {
      filtro.agente = agente;
    }
    
    // Filtrar por rango de fechas si se proporciona
    if (fechaInicio || fechaFin) {
      filtro.creadoEn = {};
      if (fechaInicio) {
        filtro.creadoEn.$gte = new Date(fechaInicio);
      }
      if (fechaFin) {
        // Ajustar para incluir todo el día
        const finDia = new Date(fechaFin);
        finDia.setHours(23, 59, 59, 999);
        filtro.creadoEn.$lte = finDia;
      }
    }
    
    console.log('Consultando leads con filtro:', JSON.stringify(filtro, null, 2));
    
    // Obtener los leads que coincidan con el filtro
    const leads = await db.collection('costumers').find(filtro).toArray();
    
    // Procesar los datos para la gráfica
    const datosGrafica = [];
    const ventasPorDia = {};
    
    leads.forEach(lead => {
      if (!lead.creadoEn) return;
      
      const fecha = new Date(lead.creadoEn);
      const fechaStr = fecha.toISOString().split('T')[0];
      
      if (!ventasPorDia[fechaStr]) {
        ventasPorDia[fechaStr] = {
          fecha: fechaStr,
          ventas: 0,
          puntaje: 0,
          conteo: 0
        };
      }
      
      ventasPorDia[fechaStr].ventas += 1;
      ventasPorDia[fechaStr].puntaje += Number(lead.puntaje) || 0;
      ventasPorDia[fechaStr].conteo += 1;
    });
    
    // Calcular promedios y formatear datos para la gráfica
    Object.values(ventasPorDia).forEach(dia => {
      datosGrafica.push({
        fecha: dia.fecha,
        ventas: dia.ventas,
        puntaje: dia.conteo > 0 ? dia.puntaje / dia.conteo : 0
      });
    });
    
    // Ordenar por fecha
    datosGrafica.sort((a, b) => new Date(a.fecha) - new Date(b.fecha));
    
    console.log(`Datos de gráfica generados: ${datosGrafica.length} puntos de datos`);
    
    res.json(datosGrafica);
    
  } catch (error) {
    console.error('Error al obtener datos para la gráfica:', error);
    res.status(500).json({
      success: false,
      message: 'Error al obtener datos para la gráfica',
      error: error.message
    });
  }
});



// Endpoint para crear un nuevo lead
app.post('/api/leads', async (req, res) => {
  // Set CORS headers
  res.header('Access-Control-Allow-Origin', req.headers.origin || '*');
  res.header('Access-Control-Allow-Methods', 'POST, OPTIONS');
  res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  res.header('Access-Control-Allow-Credentials', true);
  
  // Handle preflight
  if (req.method === 'OPTIONS') {
    return res.status(200).end();
  }

  try {
    const leadData = req.body;
    console.log('=== NUEVA SOLICITUD EN /api/leads ===');
    console.log('Datos recibidos:', leadData);
    
    // Validar datos del lead
    const requiredFields = ['telefono_principal', 'direccion', 'tipo_servicio', 'nombre_cliente'];
    const missingFields = requiredFields.filter(field => {
      const value = leadData[field];
      return value === undefined || value === null || value === '';
    });
    
    if (missingFields.length > 0) {
      console.error('Campos faltantes o inválidos:', missingFields);
      return res.status(400).json({
        success: false,
        message: 'Faltan campos requeridos o son inválidos',
        missingFields: missingFields
      });
    }
    
    // Se ha eliminado la validación de duplicados para permitir guardar cualquier lead
    console.log('Guardando nuevo lead sin validación de duplicados');
    
    // Crear nuevo lead con formato consistente
    const newLead = {
      ...leadData,
      fecha_creacion: new Date(),
      status: leadData.status || 'PENDING',
      creadoEn: new Date(),
      actualizadoEn: new Date(),
      // Agregar campos adicionales con valores por defecto
      puntuacion: leadData.puntuacion || 0,
      fuente: leadData.fuente || 'WEB',
      asignadoA: leadData.asignadoA || null,
      notas: leadData.notas || [],
      historial: [{
        accion: 'CREADO',
        fecha: new Date(),
        usuario: leadData.usuario || 'SISTEMA',
        detalles: 'Lead creado a través del formulario web'
      }]
    };
    
    // Insertar en la base de datos
    const result = await db.collection('costumers').insertOne(newLead);
    
    console.log('Lead creado exitosamente con ID:', result.insertedId);
    
    // Responder con éxito
    return res.status(201).json({
      success: true,
      message: 'Lead creado exitosamente',
      data: {
        id: result.insertedId,
        ...newLead
      }
    });
    
  } catch (error) {
    console.error('Error al procesar el lead:', error);
    
    // Manejar errores de duplicados
    if (error.code === 11000) {
      return res.status(409).json({
        success: false,
        message: 'Ya existe un lead con este número de teléfono',
        error: error.message
      });
    }
    
    return res.status(500).json({
      success: false,
      message: 'Error al procesar el lead',
      error: process.env.NODE_ENV === 'development' ? error.message : 'Error interno del servidor'
    });
  }
});

// Iniciar el servidor
const server = app.listen(PORT, '0.0.0.0', async () => {
  await connectToMongoDB();
  console.log(`\n=== Configuración del Servidor ===`);
  console.log(`Servidor corriendo en el puerto: ${PORT}`);
  console.log(`Entorno: ${process.env.NODE_ENV || 'development'}`);
  console.log(`\n=== URLs de Acceso ===`);
  console.log(`- Local: http://localhost:${PORT}`);
  console.log(`- Red local: http://${getLocalIp()}:${PORT}`);
  console.log('======================================');
});

// Función para obtener la IP local
function getLocalIp() {
  const os = require('os');
  const ifaces = os.networkInterfaces();
  
  for (const iface of Object.values(ifaces)) {
    for (const details of iface) {
      if (details.family === 'IPv4' && !details.internal) {
        return details.address;
      }
    }
  }
  
  return 'localhost';
}

// Manejo de cierre del servidor
process.on('SIGINT', () => {
  console.log('\nApagando el servidor...');
  server.close(() => {
    console.log('Servidor apagado');
    process.exit(0);
  });
});
